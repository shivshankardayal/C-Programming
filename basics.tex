\chapter{Basics of C}
C is a compiled programming language developed by Dennis Ritchie. It is a
small, fast, portable, succint  and relatively low-level language. It was
originally meant to replace assembly language for system programming and it has
been successful at that. It may be dirty but is quick. It may have its quirks
but it is a success. C is really so simple yet so deceptive(we will see later
how). C and Unix were born almost together in early 1970s at AT\&T Bell
Labs. Then Unix was ported in C and the notion that operating systems can be
only written in assembly language, because it has to do time critical things,
was destroyed. After that Unix became very popular and since C compiler used to
come with it C also became very popular because people found it much easier to
program in compared to assembly language. Other proprietary operting systems
were also written using C. So, essentially what happened that there is a lot of
code base which is there in C. Also, C++â€™s backward compatibility is one of the
reasons why C++ is so popular. When C was invented there was no structured
programming language and code was mostly written in assembly. With C it gave
the power of assembly and benefits of structured language like code reuse,
modularity, and portability among others. Because of these reasons C became
immensely popular and is still popular.

\section{History}
C was formally delivered to this world in 1972 and conceived by Dennis
MacAlistair Ritchie in 1968. What happened was there was a project for
development of a text processor and GE-645 was bought by AT\&T Bell Labs. At
that time Ken Thompson had developed a game called ``Space Travel''. Then they
had another machine PDP-11. Before that they had PDP-7. Now all the time the
code for ``Space Travel'' had to be rewritten and also the Unix had to be
ported. So when C was invented it was used to write Unix code in C. And then
``Space Travel''. I do not know what was the real motivation the language, the
OS or the game. In 1972 C was formally announced. C takes its features from
BCPL a language by Martin Richard and B by Ken Thompson. AT\&T Bells labs gave
Unix and a C compiler to many universities at a normal fees and it grew with
leaps and bounds from there and became a ubiquitous language. For many years
``The C Programming Language'' served as a reference of C. Later it was
standardized by ANSI and then by ISO standards.

\section{Why C?}
Because it is the most common denominator. Any language be it C++, Java, Perl,
Python etc have got bindings in C. Whenever you are willing to extend these
languages you need to know C. Also, if by any chance you are going towards
system programming you need to C. C is everywhere. There is no escape from
learning it; it does not matter whether you like it or not.

There is one more important point worth noting here is that C++ is far more
complex compared to C. Also, the runtime calculations of C++ make it slightly
slower than C. The library of C is much smaller than C. Therefore wherever
there is a memory constraint or extreme high performance is needed C is
preferred. The simple syntax of C means its code is very verbose for programmer
in the sense that if you read code then you can very easily see what
instructions the code is going to translate into.

It is very easy to write interfaces to other languages because other languages
expose there objects in terms of C structures not the other way around. The
reason for this is huge popularity of C and large code base perhaps.

One more important feature is portability. Note that if you want your program
to have high degree of portability then you should not use C99 features but
rather ANSI C because ANSI C compilers are available on most platforms. Even
though Java claims to be portable or other interpreted languages they are
limited by the fact that the interpreters or VMs(JVM in case of Java) is not
available on all the platforms. Therefore, C is the MOST portable language. :-)

\section{Comparison with Other Pogramming Languages}
C is a structured, statically typed, somewhat low-level, high-performance
compiled language. It does not support object-oriented programming like most
modern programming including C++, Java, Perl, Python, Ruby etc. However, that
does not mean you cannot do object-oriented programming in C. It is just that C
does not have support at the language level and it is painful to do so. C is
low level because it allows you to handle memory contents directly. You have
something called void which is raw representation of memory content. C also
does not support functional or generic programming but again it is possible to
do so with painful hacks. One of the coveted features is C programs deliver
very high performance if written correctly as it does not have reunite
penalties of virtual functions of OOP (object-oriented programming) languages.
While C is not meant for functional programming it is nonetheless possible to
do functional programming to some extent. We will implement some object oriented
features and functional programming features later in the book.

\section{What is a Computer Program?}
You may know a computer consists of many components and one of the
most or rather most important part is processor often named as CPU (central
processing unit). The logic gates in CPUs are formed and instructions like ADD
(addition), SUB (subtraction), MUL (multiplication), DIV (division) etc are
implemented in hardware of CPU. When we write a program say C program the
instructions(code) given in our program is translated to a format which
operating  ystem can understand. In our case that is GNU/Linux this executable
format is known as ELF (executable and linkable format). For the curious you
can read \url{http://en.wikipedia.org/wiki/Executable_and_Linkable_Format} and
there are lots of specification for different CPUs. Then operating system
interprets these files and ask CPU to perform action. So a C program does not
directly talk to processor but it rather talks to operating system or rather
kernel of the operating system and in turn the operating system or kernel
provides services to your program. There is a typical life cycle in development
of a program. It has been given as a flowchart in figure \ref{fig:lifecycle}.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}[node distance=1.8cm]
  \node (start) [startstop] {Start};
  \node (enterprogram) [process, below of=start] {Enter Program};
  \node (programcode) [process, left of=enterprogram, xshift=-2cm] {Program Code};
  \node (editprogram) [process, below of=enterprogram] {Edit Source File};
  \node (compileprogram) [process, below of=editprogram] {Compile Program};
  \node (ccompiler) [process, left of=compileprogram, xshift=-2cm] {C Compiler};
  \node (syntaxerrors) [decision, below of=compileprogram, yshift=1.2cm] {Syntax Errors};
  \draw [arrow] (syntaxerrors.east) -- +(1cm, 0) |- ([yshift=-0.1cm]editprogram.east);
  \node (link) [process, below of=syntaxerrors, align=center] {Link with\\System Library};
  \node (systemlibrary) [process, left of=link, xshift=-2cm] {System Library};
  \node (executecode) [process, below of=link] {Execute program};
  \node (input) [io, left of=executecode, xshift=-2cm] {Input Data};
  \node (error) [decision, below of=executecode, align=center, yshift=1.2cm] {Logic and data errors};
  \node (success) [process, below of=error] {Correct output};
  \node (stop) [startstop, below of=success] {Stop};
  \draw [arrow] (start) -- (enterprogram);
  \draw [arrow] (programcode) -- (enterprogram);
  \draw [arrow] (enterprogram) -- (editprogram);
  \draw [arrow] (editprogram) -- (compileprogram);
  \draw [arrow] (ccompiler) -- (compileprogram);
  \draw [arrow] (compileprogram) -- (syntaxerrors);
  \draw [arrow] (syntaxerrors) -- (link);
  \draw [arrow] (systemlibrary) -- (link);
  \draw [arrow] (link) -- (executecode);
  \draw [arrow] (input) -- (executecode);
  \draw [arrow] (executecode) -- (error);
  \draw [arrow] (error) -| (input);
  \draw [arrow] (error.east) -- +(1.5cm, 0) |- ([yshift=0.1cm]editprogram.east);
  \draw [arrow] (error) -- (success);
  \draw [arrow] (success) -- (stop);
  \node [above] at ([xshift=1cm]editprogram.north east) {\textbf{Source Program}};
  \node [above] at ([xshift=0.3cm, yshift=0.2cm]syntaxerrors.east) {\textbf{Yes}};
  \node [below] at ([xshift=0.7cm, yshift=0.3cm]syntaxerrors.south) {\textbf{No}};
  \node [above] at ([xshift=1.35cm, yshift=0.2cm]error.east) {\textbf{Logical error}};
    \node [above] at ([xshift=-1cm, yshift=0.2cm]error.west) {\textbf{Input error}};
\end{tikzpicture}
\end{center}
\caption{Life cycle of a program}
\label{fig:lifecycle}
\end{figure}

As you can see in the figure first we need to edit a source file which is done
by using a text editor. The C source code files have the extension \texttt{.c}
while C header files have the extension \texttt{.h} which are then compiled to
give us a executable binary if no compilation errors occur. The output of
compilation can be a library which is linked to other executables. For now, we
will focus only on executables. In case of compilation errors we need to edit
the code again so that no compilation errors/warnings are there. Then we can
run the code which can lead to two different types of errors. One is input
error and second is logical error in our program. Both will cause the program
to not give desired output. Input error is easy to fix most of the time but
logical errors can be nasty and many times you will need to use a debugger like
GDB.

\section{Attributes of a Program}
Any program cannot be considered a good program unless it satisfies following
requirements or possess following attributes(Note: These are generic
attributes and not specific to C programming language):
\begin{enumerate}
  \item \textbf{Correctness:} Correctness means that a program satisfies its
    requirement specification. It means that for a specified input the
    specified output should be produced. This particular attribute is of most
    significance. It does not matter whether other attributes are present or
    not but this one is a must. If a program behavior is not correct then it is
    of no use.

  \item \textbf{Efficiency:} Efficiency is second to correctness only. Say you
    are developing a text editor and you take 5 seconds to load a 10KB text
    file then by no means you can persuade a user to use you text editor. A
    program/software must be as efficient as possible. Sometimes it clashes
    with other attributes and also depend on the problem domain that how strict
    are the requirements.

  \item \textbf{Security:} A very highly desirable feature in programs which
    deal with more than one computer and also for desktop applications. It is
    very bad if someone can take advantage of buffer overflow, stack overflow,
    integer overflow etc. in your program and you must guard against these at
    all times. Note that to provide security you must put extra checks which
    will go against efficiency.

\item \textbf{Robustness:} Sometimes users will not give correct inputs. For
  example they may enter a character when an integer is asked for or they can
  give input beyond range. In such cases you must handle the erroneous
  input. This is just one example. Sometimes your memory allocation may
  fail. The rule is program defensively. All such input validations and checks
  on memory do take a toll on our second attribute but that does not mean that
  we can neglect it. This is especially true for software running on multiple
  computers(known as distributed systems) and critical systems like health care
  machines.

\item \textbf{Maintainability:} Even a one line program has to be maintained if
  it is worth it! Typically the life of a program far exceeds the development
  time. In almost all the cases the original programmer is not
  maintainer. Because of these reasons you must strive for maintainability. You
  should follow some coding standards like I highly recommend
  \url{http://www.gnu.org/prep/standards/}. Clear documentation is one of the
  prerequisites of maintainability.

\item \textbf{Extensibility:} Let us take our example of text editor and say
  our editor is complete. Now someone else would like to provide a plugin which
  will enable syntax highlighting and project management for this editor. So,
  in order to do so you can choose a plugin-based extensible architecture or
  you can allow them to extend the editor using scripting languages like Guile,
  Python, Lua etc.This features allows user to collaborate and make your
  program better. Remember the rule is the more the merrier here.

\item \textbf{Portability:} It is an elusive and painful goal. Let us say we
  write our text editor GUI using something like Xlib directly then we will
  have to port the entire GUI for other non X-based OSes. So we can choose some
  cross-platform GUI libraries like GTK+, Qt, WxWidgets etc. Even then when
  system calls come in your software you can do not much but either write
  wrappers and do conditional compilation.
\end{enumerate}

\section{Tools of Trade}
To program in C we need an editor, a C compiler, a debugger and possibly a
memory leak checker. Since this books is focused on GNU/Linux you can choose
from several excellent options like VI, Emacs, Kate, Kwrite, Gedit and many
more. For compiler I am going to use GCC. As debugger GDB is the tool of
choice. For memory leak, memory corruption etc we will use Valgrind. We will
learn these as we go along in the book.

\section{Bits and Bytes}
The smallest unit a computer can understand is called a bit. The values for a
bit is either 0 or 1. Consider a voltage. It can be 0V or 1.5V or whatever the
core CPU voltage is. CPU does not understand numbers but voltages. You
cannot expect an electronics hardware to understand the same semantics of 0 and
1 which we know. 0 and 1 are abstraction of CPUs voltages in programming. Four
bits form a nibble and eight(on most computers) form a byte. A byte is the area
of memory which can be addressed by CPU and its content manipulated. To address
a memory a CPU has say 4 or 8 or up to 256 pins. For example, in a common
32-bit CPU there are 32 pins whose voltages may represent 0 or 1. Consider all
pins are low i.e. 0 then the memory location pointed to is
00000000000000000000000000000000 i.e. a 8 bit memory at location 0 can be
accessed. This memory is also called primary memory or RAM. So computing this
way we can see that a 32-bit processor can access 
$2^{32}$ bytes or 4,294,967,296 bytes. You can arrive at 
this number by 4*1024*1024*1024. This is equivalent to 4GB of RAM. However,
modern Intel 32-bit processors have 36 physical pins to address up to 64GB of
memory. That does not mean that all 64-bit CPUs have 64 pins for addressing
memory as 16 Exabytes(approximately $10{18}$) is really, really huge amount of
memory which is not needed by any single monolithic system practically and will
be very expensive, thus it is not practical.

Since a byte has 8 bits, its value may range from 0 to 255 as $2^8$ is 256. For
unsigned data type this will be the range. When all bits are 0 value is zero
and when all are high it is 255. Computers use twoâ€™s complement form to
represent binary number. So if these 8-bits represent signed number the range
will be from $âˆ’2^7$ to $2^7âˆ’1$ that is -128 to 127. As you will see later at lowest
levels C allows you to access even one bit using something called bit-fields.

If you read specification it will signify the range of one 8-bit byte as -127
to 127 because it also takes in to consideration of 1's complement computers in
which positive and negative zeroes are different.

There are certain rules in every language, certain grammar which dictates the
way language will be spoken and written. It has a script to write
using. Similarly, programming languages have BNF (Backus-Naur Form)
context-free grammar. There are valid characters in a programming language and
a set of keywords. There are constructs to handle control flow, loops
etc. There are facilities provided by language to deal with numbers and strings
separately, to reuse the code and some basic data structures to facilitate
programming. However, programming language ruleset is very small compared
to a natural programming language. Also, when using natural programming
language like talking to someone or writing something the other person can
understand your intent but in programming you cannot violate rules. The grammar
is context-free. Compilers or interpreters cannot deduce your intent by reading
code. They are not intelligent. You make a mistake and it will refuse to listen
to you no matter what you do. Therefore, it is very essential to understand
these rules very clearly and correctly.

\section{The C Character Set}
The following form the C character set you are allowed to use in it:

\begin{Verbatim}[frame=single]
[a-z] [A-Z] [0-9] ~ ! # % ^ & * ( ) - = [ ] \ ; ' , . / _ + { } | : " < > ?
\end{Verbatim}
\index{character set}

This means along with other symbols you can use all English alphabets (both
uppercase and lowercase) and Arabic numerals. Symbols like \texttt{\$} and
\texttt{@} are not part of C's character set. But strings can contain any
these characters also. Strings are sequence of characters with double quotes
and double quotes iteself are escaped with \texttt{$\backslash$}. Also,
\texttt{\$} and \texttt{@} can also be value of characters. Characters are
values containing single characters withing single quotes. We will see more of
these in their individual sections. However, English is not the only
spoken language in the world. Therefore in other non-English speaking counties
there are keyboard where certain characters present in above set are not
present. The inventors of C were wise enough to envision this and provide the
facility in form of trigraph sequences. Given below is the trigraph sequence
table:

\begin{table}[H]
 \begin{center}
 \caption{Trigraph Sequences}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{Trigraph}&\textbf{Equivalent}&\textbf{Trigraph}&\textbf{Equivalent}&\textbf{Trigraph}&\textbf{Equivalent}\\
\hline
??=&\#&??'&\textasciicircum&??!&|\\
\hline
??(&[&??)&]&??$<$&\{\\
\hline
??$>$&\}&??/&\textbackslash&??-&\textasciitilde\\
\hline
\end{tabular}
\end{center}
\end{table}
\index{trigraph sequences}

However, you should refrain from using trigraph sequences for portability 
reasons as suggested by GNU coding standards.

\section{Keywords}
The following are reserved keywords for C programming language which you are not 
allows to use other than what they are meant for:
\index{keywords}
\begin{table}[H]
 \begin{center}
  \caption{Keywords of C}
  \begin{tabular}{l l l l l}
    auto & break & case & char & const\\
    continue & default & do & double & else\\
    enum & extern & float & for & goto\\
    if & inline & int & long & register\\
    restrict & return & short & signed & sizeof\\
    static & struct & switch & typedef  & union\\
    unsigned & void & volatile & while & \_Alignas\\
    \_Alignof& \_Atomic & \_Bool & \_Complex & \_Generic \\
    \_Imaginary & \_Noreturn & \_Static\_assert & \_Thread\_local\\
  \end{tabular}
 \end{center}
\end{table}

These keywords are special in C as said and cannot be used for variable names 
or funciton names or otherwise other than in strings and comments.

\section{Identifiers}
The names which we give to our variables are known as identifiers. Something 
with which we identify the variables. In other words since memory locations are
difficult to remember for us, human beings, we assign these memory locations
more meaningful names in form of identifiers. As you have already seen what is
allowed  in C's character set but not all are allowed in an identifiers
name. Only alphabets from English language both lowercase and uppercase,
Arabic digits from zero to nine and underscore (\_) are allowed in an
identifiers name. The rule for constructing names is that among the allowed
characters it can only begin with only English alphabets and
underscore. Numbers must not be first character. For example, \texttt{x,
  \_myVar, varX} and \texttt{yourId78} are all valid names. However, take care
with names starting from underscore as they are mostly used by different
library authors. Invalid identifier examples are \texttt{9x, my\$} and
\texttt{your age}. Please read this section carefully and make sure understand
the rules for naming identifiers. Later at the end of chapter there are some
simple problems to practice with.

\section{Programming}
Let us revisit our first program and try to understand what it does. Here I am 
giving code once again for quick reference:

\begin{Verbatim}[frame=single]
// My first program
/* Description: This program does nothing.*/

#include <stdio.h>

int main(int argc, char* argv[])
{
  return 0;
}
\end{Verbatim}

You can now issue a command as \texttt{\$gcc nothing.c} where 
\texttt{nothing.c} is the filename by which you saved the source code. Note 
that \texttt{\$} is the prompt not part of command itself. Then you can do an 
ls and you will find that \texttt{a.out} is a file which has been produced by 
gcc. Now you can run this program by saying \texttt{\$./a.out} and nothing 
will happen. But if you type \texttt{\$echo \$?} then you will find that 0 is 
printed on screen which is nothing but 0 after \texttt{return} of our program.

As you can see this program does almost nothing but it is fairly complete 
program and we can learn a lot from it about C. Let us try to dissect it line
by line. The first line is a comment. 
Whenever C compiler parses C programs and it encounters \texttt{//} it ignores 
rest of line as code i.e. it does not compile them. This type of single line 
comment were introduced in C99 standard and if your compiler is really old the 
compiler may give you error message about it. The second line is
also comments. Anything between \texttt{/*} and \texttt{*/} is ignored like 
\texttt{//}. However, be careful of something like \texttt{/* some comment */
  more comment */}. Such comments will produce error messages and your program
will fail to compile. The reason for this is when first \texttt{*/} is
encountered by parser or compiler it will complete its token for the comment
and then further portion which we intented to be part of comment will cause
syntax error. 

Comments are very integral part of programming. They are used to describe 
various things. You can write whatever you want. They may also be used to 
generate documentation with tools like doxygen. Typically comments should tell
what the program is doing not how. Sometimes how can be covered, when the logic
is really complex. One should be generous while commenting the code.

The next line is \texttt{\#include <stdio.h>}. \texttt{\#include} is a
preprocessor directive. The preprocessor directive is handled by the C
preprocesor which is handled by C preprocessor which looks in four directories
for include files. The include filename comes after \texttt{\#include} either in
angular brackets or double quotes. The C preprocessor looks for these at four
different places at least out of which one or posiibly two is of interest for
now as we are dealing with angular brackets. Depending on the way your compiler
is installed the file \texttt{stdio.h} may be in \texttt{/usr/include} or
\texttt{/usr/local/include} but then again it may be in a non-standard path
also although possibility of that is very less and then it is controlled by
parameters whose discussion is beyond the scope of book. Let us say
\texttt{stdio.h} is present in either of aforementioned directories then the C
preprocessor will copies the contents and pastes them in source file along the
way putting \texttt{\#line} macros which are used for debugging
purposes. \texttt{\#line} macro is discussed later in the chapter which deals
with macros. You can see the output of C preprocessor by typing \texttt{\$gcc
  -E nothing.c} since it will scroll a lot on you terminal you can use a pager
like \texttt{less} to read it. The \texttt{-E} tells \texttt{gcc} to just allow
preprocessoing and not compile and link the file.

Next line is \texttt{int main(int argc, char* argv[])}. Now this is very special
function. Every complete executable(shared objects or dlls or archive
libraririe do not have main even though they are C programs) C program will
have one main function unless you do assembly hacking. This function is where
the programs start. The first word \texttt{int} is a keyword which shirthand
for integer. This signifies the return type of function. \texttt{main} is the
name of the function. Inside parenthesis you see \texttt{int argc} which tells
how many arguments were passed to program and is short form of argument
count. While \texttt{char* argv[]} is a pointer to array which we will see
later. For now let us just remember that it holds all the arguments to the
program including the program name.

Next is a brace. The scope in C is determined by braces. Something outside any
brace has global scope (we will see these later), something inside first level
of brace has function or local scope. Something inside second or more level of
braces have got that particular block scope. Scope here means that when there
will be a closing brace that particular variable which is valid in that scope
will cease to exist. However, we do not have to worry about that yet as we do
not have any variable. Just note that a corresponding closing brace will be the
end of main function. For every opening brace which starts a scope a closing
brace is mandatory.

Next line is \texttt{return 0;} This means whoever has called \texttt{main()}
will get a 0 as \texttt{return} is returning 0. In this case, receiver is the
shell or operating system 
which has invoked the very program. The semicolon is called the terminator and
used also on Java or C++ for example. The very requirement of semicolon is to
terminate the statement and move on to next statement.

However, the program shown does not do much. Let us write a program which has
some more functionality and we can explore more of C. So here is a program
which takes two integers as input from users and presents their sum as
output. Here is the program:

\begin{Verbatim}[frame=single]
// My second program
// Author: Shiv S. Dayal
// Description: It adds two numbers

#include <stdio.h>

int main()
{
  int x=0, y=0, sum=0;

  printf("Please enter an integer:\n");
  scanf("%d", &x);

  printf("Please enter another integer:\n");
  scanf("%d", &y);

  sum = x + y;

  printf("%d + %d = %d\n", x, y, sum);

  return 0;
}
\end{Verbatim}
and the output is:
\begin{Verbatim}[frame=single]
shiv@shiv:~/book/code$ ./addition
Please enter an integer:
7
Please enter another integer:
8
7 + 8 = 15
shiv@shiv:~/book/code$
\end{Verbatim}

Note that \texttt{shiv@shiv:~/book/code\$} is the prompt.

Let us discuss new lines one by one. The line \texttt{int x=0, y=0, z=0;} is
declaration and definition or initialization of three ints. \texttt{int}
keyword in C is used to represent integers. Now we have three integers with
there values set to 0. Note that how the variables are separated by commas and
terminated by semicolon(as we saw in last program also). We could have also
written it like this:

\begin{Verbatim}[frame=single]
int x;
int y;
int z;

x = 0;
y = 0;
z = 0;
\end{Verbatim}

or

\begin{Verbatim}[frame=single]
int x, y, z;

x = y = z = 0;
\end{Verbatim}

However, the first method is best and most preferred as it prevents use before
definition. \texttt{int} is a data-type in C. \texttt{x, y,} and \texttt{z} are
called variables of type \texttt{int}. This means that the size of these
variables will be same as \texttt{int}. Note that 
C is a statically typed language and all types have predefined memory
requirements. In cour case, \texttt{int} requires 4 bytes on 32-bit and 64-bit
systems but 2 bytes on 16-bit systems.

Let us learn a bit about \texttt{printf}. This function is declared in
stdio.h. The prototype of \texttt{printf()} is

\begin{Verbatim}[frame=single]
int printf(const char *restrict format, ...);
\end{Verbatim}

The first argument format is what we have in first two function calls. The
second is a \texttt{...} which means it can take variable number of arguments
known as variable-list. We have seen this in the third call.This means it will
take a string with optional variable no. of arguments. The string is called the
format-string and determines what can be printed with supplied arguments. These
\texttt{...} are used to supply variable no. of arguments. In the first two
\texttt{printf()} statements we just print the format-string so that is
simple. However, in the last one, we have format as \texttt{\%d} which
signifies a decimal integer. The integers printed are in the same order in
which they were supplied.

\texttt{scanf()} is scan function which scans for keyboard input. As by now you
know that \texttt{\%d} is for decimal integer but we have not said \texttt{x}
or \texttt{y}. The reason is \texttt{x} and \texttt{y} are names for memory
addresses while
\texttt{\&x} and \texttt{\&y} are the addresses of \texttt{x} and \texttt{y} in
memory. \texttt{scanf()} needs the memory address to which it can write the
contents to. You will see \texttt{\&} operator in action later when we deal
with pointers. Just remember for now that to use a simple variable with
\texttt{scanf()} requires \texttt{\&} before its name.

Till now we have just seen only \texttt{int} data-type but then there are more
data types for other types of numbers, characters and strings. Let us see them
one by one.

\section{Data Types}
What are data types? Why C needs data types? C is a statically typed language
that is every variable has a type associated with it. These types determine
what kind of values these variables can hold and how they will be interpreted.
Say we encode
character `A' for 10101 will it be easy for you to see A or numbers. Also,
numbers range from $-\infty$ to $\infty$. Also, since C is statically typed the
sizes of data types have to be known at compile time. Because the data type is
known a compiler can detect whether we are storing corect type of values in
corect type of variables at compilation time. Also, it allows compiler to do
certain optimization which efffects the runtime performance of the program
during execution. There are four types of
data types. Integral, floating-point, arrays and pointers. Here, I will deal
with the two former types and leave latter two for later. The integral types
are \texttt{char, short int, int, long} and \texttt{long long} and
floating-point types are \texttt{float, double} and \texttt{long
  double}. \texttt{signed} and \texttt{unsigned} are sign modifiers which also
modified the range of data types but do not affect their memory
requirements. By default all basic data types are \texttt{signed} in nature and
you must qualify you variables with \texttt{unsigned} if you want that
behavior. \texttt{short} and \texttt{long} are modifiers for size which the
data type occupies but I consider them as different types because memory
requirements are different. The ranges of integral data types directly reflect
their memory requirements and if you know how much memory they are going to
occupy you can easily compute their ranges. The range of floating-point comes
from IEEE specification. IEEE standard document 754 governs the binary
representation of floating point numbers which you can read at
\url{http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF}. This is
not available from IEEE website itself as they sell the specification's
electronic copies.

Let us write a program to find out ranges for integral data types:

\begin{Verbatim}[frame=single]
// Description: It gives ranges of integral data types

#include <stdio.h>
#include <limits.h>

int main()
{
  printf("Size of char is..........%d\n", sizeof(char));
  printf("Size of short int is.....%d\n", sizeof(short int));
  printf("Size of int is...........%d\n", sizeof(int));
  printf("Size of long is..........%d\n", sizeof(long));
  printf("Size of long long is.....%d\n", sizeof(long long));
  printf("Size of float is.........%d\n", sizeof(float));
  printf("Size of double is........%d\n", sizeof(double));
  printf("Size of long double is...%d\n", sizeof(long double));c

  return 0;
}
\end{Verbatim}

Here \texttt{sizeof} is a compile time operator which computes size of any type
passed to it as an argument. So it is computing sizes of all the data types as
shown in the program. The output is given below:

\begin{Verbatim}[frame=single]
Size of char is..........1
Size of short int is.....2
Size of int is...........4
Size of long is..........8
Size of long long is.....8
Size of float is.........4
Size of double is........8
Size of long double is...16
\end{Verbatim}

Please note that the output shown is on 64-bit machine and it will be different
on 32-bit machines.

\section{Integers}
Integers are probably simplest to understand of all data types in C so I am
discussing them before any other type. As you have seen the keyword for
declaring integer type is \texttt{int}. An integer can be 2 bytes or 4 bytes. A
16-bit compiler will have integer of 2 bytes while a 32-bit or 64-bit compiler
will have a 4 byte integer. The specified minimum size of an integer is 2
bytes. Since most modern computers are either 32-bit with
64-bit becoming more dominant we will assume in this book that integer's size
is 4 bytes or 32-bit implicitly because 32-bit \texttt{gcc} gives a 32-bit
integer. There is a keyword \texttt{signed} which when 
applied to a data type splits the range into two parts. Since interger is 32
bit so it will be split in the range from $-2^{31}$ to $2^{31} - 1$. By default
integers, characters and long are \texttt{signed}. Floats and doubles are
always \texttt{unsigned} and have no signed counterpart. When the integer will
be \texttt{unsigned} then the positive range doubles and it becomes $0$ to
$2^{32} - 1$. When the value of intger is more than its range then the values
rotate in the using modulus with the largest value of the range which is also
known as \texttt{INT\_MAX} or \texttt{INT\_MIN}. For \texttt{unsigned} types it
is \texttt{UINT\_MAX}. These are macros and are defined in \texttt{limits.h}
which you can find in \texttt{/usr/include} or \texttt{/usr/local/include} by
default.

There are four different types of integers based on their storage
reuirement. \texttt{short int, int, long,} and \texttt{long long.} Short
integers are always two bytes. Signed short integer has a range of -32768 to
32767 while unsigned of that has a range of 0 to 65535. Plain integers
i.e. \texttt{int} has already been discussed. \texttt{long} are having a
minimum storage reuirement of 4 bytes. Usually it is large enough to represent
all memory addresses of the system because \texttt{size\_t} is
\texttt{unsigned long.}

\section{Characters}
A \texttt{char} is 1 byte i.e. 8 bits or \texttt{CHAR\_BIT} bits. So its signed
version i.e. 2's 
complement where half the range is negative and half is positive will have
value from -128 to 127. Well that is not exactly opposite because we have only
one zero for positive and negative numbers. If it would have been 1's
complement then range would have been from -127 to 127 but since computers
follow 2's complement the specification clearly mentions that range should be
from $-2^7$ to $2^7 - 1.$ Note that chars are fundamentally integral types and
ascii symbols are first 128 numbers or in other words they are 7-bit numbers.

So a character `0' is internally 48 in decimal which is its integral or
internally it is handled as a sequence of binary numbers representing
\texttt{0x30} in hexdecimal. These integral values for characters are known as
ASCII value. A full table of ASCII values is given in the appendix A.

A simple program which takes input for few characters and then prints them on
console along with their ascii values is given below:

\begin{Verbatim}[frame=single]
#include <stdio.h>

int main()
{
  char c = 0;
  char c1 = 0, c2 = 0;

  printf("Enter a character on your keyboard and then press ENTER:\n");
  scanf("%c", &c);
  printf("The character entered is %c and its ASCII value is %d.\n", c, c);
  // Their remains '\n' in the stdin stream which needs to be cleared.
  getchar();
  printf("Enter a pair of characters on your keyboard and then press \
ENTER:\n");
  scanf("%c%c", &c1, &c2);
  printf("The characters entered are %c and %c and their ASCII \
values are %d and %d respectively.\n", c1, c2, c1, c2);

  short int si = 0;

  si = c1 + c2;

  printf("The sum of c1 and c2 as integers is %hd.\n", si);

  return 0;
}
\end{Verbatim}

A sample run may have following output:

\begin{Verbatim}[frame=single]
$ ./a.out
Enter a character on your keyboard and then press ENTER:
1
The character entered is 1 and its ASCII value is 49.
Enter a pair of characters on your keyboard and then press ENTER:
12
The characters entered are 1 and 2 and their ASCII values are 49 and 50 respectively.
The sum of c1 and c2 as integers is 99.
\end{Verbatim}

As you can see from the program that characters are internally stored as
itnegers and we can even perform integers which we normally perform on
numbers like addition as shown. We can perform other operation as subtraction,
multiplication and division, however, most of the time addition or subtraction
only makes sense to advance the characters in their class. Multiplication and
division of characters with other characters or integers does not make sense.

One problem of concern is the extra \texttt{\textbackslash n} in the input
stream. It does not cause trouble with integers but when you want to read
characters then the \texttt{Enter} or \texttt{Return} keys which may be left
over from the last input will cause trouble. \texttt{\textbackslash n} is
recognized as a character and will be assigned to next variable if it is in
\texttt{stdin.} One of the ways to remove it is to make a call to
\texttt{getchar} which reads one character from the \texttt{stdin} stream.

\section{Sizes of Integer Types}
Before going any further and discussing floats and doubles let us take a look
at limits of various integral type as specified in specification. Note that the
output from your compiler may be larger but not smaller because these are
minimum values. The limits given below and the limits which will be given for
floating point numbers are described in \texttt{<limits.h>} and
\texttt{<float.h>}.

\begin{itemize}
\item[---] number of bits for smallest object that is not a bit-field (byte)\\
\texttt{CHAR\_BIT}\hfil\hspace*{2cm}\texttt{8}
\item[---] minimum value for an object of type \texttt{signed char}\\
\texttt{SCHAR\_MIN}\hfil\hspace*{2cm}\texttt{-127 //} $-(2^7 - 1)$
\item[---] maximum value for an object of type \texttt{signed char}\\
\texttt{SCHAR\_MAX}\hfil\hspace*{2cm}\texttt{+127 //} $2^7 - 1$
\item[---] maximum value for an object of type \texttt{unsigned char}\\
\texttt{UCHAR\_MAX}\hfil\hspace*{2cm}\texttt{255 //} $2^8 - 1$
\item[---] minimum value for an object of type \texttt{char}\\
\texttt{CHAR\_MIN}\hfil\hspace*{2cm}\textit{see below}
\item[---] maximum value for an object of type \texttt{char}\\
\texttt{CHAR\_MAX}\hfil\hspace*{2cm}\textit{see below}
\item[---] maximum number of bytes in a multibyte character, for any supported
  locale\\
\texttt{MB\_LEN\_MAX}\hfil\hspace*{2cm}\texttt{1}
\item[---] minimum value for an object of type \texttt{short int}\\
\texttt{SHRT\_MIN}\hfil\hspace*{2cm}\texttt{-32767 //} $-(2^{15} - 1)$
\item[---] maximum value for an object of type \texttt{short int}\\
\texttt{SHRT\_MAX}\hfil\hspace*{2cm}\texttt{+32767 //} $2^{15} - 1$
\item[---] maximum value for an object of type \texttt{unsigned short int}\\
\texttt{USHRT\_MAX}\hfil\hspace*{2cm}\texttt{65535 //} $2^{16} - 1$
\item[---] minimum value for an object of type \texttt{int}\\
\texttt{INT\_MIN}\hfil\hspace*{2cm}\texttt{-32767 //} $-(2^{15} - 1)$
\item[---] maximum value for an object of type \texttt{int}\\
\texttt{INT\_MAX}\hfil\hspace*{2cm}\texttt{+32767 //} $2^{15} - 1$
\item[---] maximum value for an object of type \texttt{unsigned int}\\
\texttt{UINT\_MAX}\hfil\hspace*{2cm}\texttt{65535 //} $2^{16} - 1$
\item[---] minimum value for an object of type \texttt{long int}\\
\texttt{LONG\_MIN}\hfil\hspace*{2cm}\texttt{-2147483647 //} $-(2^{31} - 1)$
\item[---] maximum value for an object of type \texttt{long int}\\
\texttt{LONG\_MAX}\hfil\hspace*{2cm}\texttt{+2147483647 //} $2^{31} - 1$
\item[---] maximum value for an object of type \texttt{unsigned long int}\\
\texttt{ULONG\_MAX}\hfil\hspace*{2cm}\texttt{4294967295 //} $2^{32} - 1$
\item[---] minimum value for an object of type \texttt{long long int}\\
\texttt{LLONG\_MIN}\hfil\hspace*{2cm}\texttt{-9223372036854775807 //} $-(2^{63} - 1)$
\item[---] maximum value for an object of type \texttt{long long int}\\
\texttt{LLONG\_MAX}\hfil\hspace*{2cm}\texttt{+9223372036854775807 //} $2^{63} - 1$
\item[---] maximum value for an object of type \texttt{unsigned long long int}\\
\texttt{ULLONG\_MAX}\hfil\hspace*{2cm}\texttt{18446744073709551615 //} $2^{64} - 1$
\end{itemize}

If the value of an object of type \texttt{char} is treated as a signed integer
when used in an expression, the value of \texttt{CHAR\_MIN} shall be the same
as that of \texttt{SCHAR\_MIN} and the value of \texttt{CHAR\_MAX} shall be the
same as that of \texttt{SCHAR\_MAX}. Otherwise, the value of \texttt{CHAR\_MIN}
shall be 0 and the value of \texttt{CHAR\_MAX} shall be the same as that of 
\texttt{UCHAR\_MAX}. The value \texttt{UCHAR\_MAX} shall equal $2^{CHAR\_BIT} -
1$.

Values given above have the form of 1's complement in which positive zero and
negative zero are treated differently while computers in general work using 2's
complement so you will notice that the minimum values are extended by 1. So for
example, \texttt{SHRT\_MIN} in \texttt{<limits.h>} is given as -32768 and so
are all minimum values.

\section{Floating Types}
Floating point representation is a lot more complicated in computers than it
is for us human beings. C specification takes floating points description and
specification from IEC 60559:1989 which is a standard for floating point
arithmetic. In C there are three types of flaoting point numbers \texttt{float,
double} and \texttt{long double.} Since all are governed by the same model I am
presenting following from specification (in following paragraphs implemenation
means compiler) for the sake of accuracy.

The characteristics of floating types are defined in terms of a model that
describes a representation of floating-point numbers and values that provide
information about an implementation's floating-point arithmetic.\footnote{The
  floating-point model is intended to clarify the description of each
  floating-point characteristic and does not require the floating-point
  arithmetic of the implementation to be identical.} The following parameters
are used to define the model for each floating-point type:
\\\\
\hspace*{1cm}\begin{tabular}{ll}
$s$&sign ($\pm$1)\\
$b$&base or radix of exponent representation (an integer $>$ 1)\\
$e$&exponent (an integer between a minimum $e_{min}$ and a maximum $e_{max}$)\\
$p$&precision (the number of base-$b$ digits in the significand)\\
$f_k$&nonnegative integers less than $b$ (the significand digits)
\end{tabular}
\\\\
A \textit{floating-point number (x)} is defined by the following model:

$$x = sb^e\sum_{k=1}^pf_kb^{-k},~~e_{min}\le~e~\le~e_{max}$$

In addition to normalized floating-point numbers ( $f_1 > 0$ if $x \ne 0$),
floating types may be able to contain other kinds of floating-point numbers,
such as \textit{subnormal floating-point numbers} ($x \ne 0, e = e_{min}, f_1 =
0$) and \textit{unnormalized floating-point numbers} ($x \ne 0, e > e_{min},
f_1 = 0$), and values that are not floating-point numbers, such as infinities
and NaNs. A \textit{NaN} is an encoding signifying Not-a-Number. A
\textit{quiet} NaN propagates through almost every arithmetic operation without
raising a floating-point exception; a \textit{signaling} NaN generally raises a
floating-point exception when occurring as an arithmetic operand.\footnote{IEC
  60559:1989 specifies quiet and signaling NaNs. For implementations that do
  not support IEC 60559:1989, the terms quiet NaN and signaling NaN are
  intended to apply to encodings with similar behavior.}

An implementation may give zero and values that are not floating-point numbers
(such as infinities and NaNs) a sign or may leave them unsigned. Wherever such
values are unsigned, any requirement in this International Standard to retrieve
the sign shall produce an unspecified sign, and any requirement to set the sign
shall be ignored. 

The minimum range of representable values for a floating type is the most
negative finite floating-point number representable in that type through the
most positive finite floating-point number representable in that type. In
addition, if negative infinity is representable in a type, the range of that
type is extended to all negative real numbers; likewise, if positive infinity
is representable in a type, the range of that type is extended to all positive
real numbers.

The accuracy of the floating-point operations (\texttt{+, -, *, /}) and of the
library functions in \texttt{<math.h>} and \texttt{<complex.h>} that return
floating-point results is implementation-defined, as is the accuracy of the
conversion between floating-point internal representations and string
representations performed by the library functions in \texttt{<stdio.h>,
  <stdlib.h>,} and \texttt{<wchar.h>}. The implementation may state that the
accuracy is unknown.

The rounding mode for floating-point addition is characterized by the
implementation-defined value of \texttt{FLT\_ROUNDS}:\footnote{Evaluation of
  \texttt{FLT\_ROUNDS} correctly reflects any execution-time change of rounding
  mode through the function \texttt{fesetround} in \texttt{<fenv.h>}.}
\\\\
\hspace*{1cm}\begin{tabular}{rl}
\texttt{-1} & indeterminable\\
\texttt{0} & toward zero\\
\texttt{1} & to nearest\\
\texttt{2} & toward positive infinity\\
\texttt{3} & toward negative infinity\\
\end{tabular}
\\\\
All other values for \texttt{FLT\_ROUNDS} characterize implementation-defined
rounding behavior.

Except for assignment and cast (which remove all extra range and precision),
the values yielded by operators with floating operands and values subject to
the usual arithmetic conversions and of floating constants are evaluated to a
format whose range and precision may be greater than required by the type. The
use of evaluation formats is characterized by the implementation-defined value
of \texttt{FLT\_EVAL\_METHOD}:\footnote{The evaluation method determines
  evaluation formats of expressions involving all floating types, not just real
  types. For example, if \texttt{FLT\_EVAL\_METHOD} is 1, then the product of
  two float \texttt{\_Complex} operands is represented in the \texttt{double
    \_Complex} format, and its parts are evaluated to \texttt{double}.}
\\\\
\hspace*{1cm}\begin{tabular}{rl}
\texttt{-1} & indeterminable;\\
\texttt{0} & evaluate all operations and constants just to the range and
precision of the type;\\
\texttt{1} & evaluate operations and constants of type \texttt{float} and\\
&\texttt{double} to the range and precision of the \texttt{double} type,\\
&evaluate \texttt{long double} operations and constants to the range and\\
&precision of the \texttt{long double} type;\\
\texttt{2} & evaluate all operations and constants to the range and precision\\
&of the \texttt{long double} type.
\end{tabular}
\\\\
All other negative values for \texttt{FLT\_EVAL\_METHOD} characterize
implementation-defined behavior.

The presence or absence of subnormal numbers is characterized by the
implementation-defined values of \texttt{FLT\_HAS\_SUBNORM, DBL\_HAS\_SUBNORM,}
and \texttt{LDBL\_HAS\_SUBNORM}:
\\\\
\hspace*{1cm}\begin{tabular}{rl}
-1 & indeterminable\footnote{Characterization as indeterminable is intended if
  floating-point operations do not consistently interpret subnormal
  representations as zero, nor as nonzero.}\\
0 & absent\footnote{Characterization as absent is intended if no floating-point
  operations produce subnormal results from non-subnormal inputs, even if the
  type format includes representations of subnormal numbers.} (type does not
support subnormal numbers)\\
1 & present (type does support subnormal numbers)
\end{tabular}
\\\\
The values given in the following list shall be replaced by constant
expressions with implementation-defined values that are greater or equal in
magnitude (absolute value) to those shown, with the same sign:

\begin{itemize}
\item[---] radix of exponent representation, $b$\\
\begin{tabular}{lr}
\texttt{FLT\_RADIX}&\hfil\hspace*{2cm}\texttt{2}
\end{tabular}
\item[---] number of base-\texttt{FLT\_RADIX} digits in the floating-point significand,
  $p$\\\\
\texttt{FLT\_MANT\_DIG}\\
\texttt{DBL\_MANT\_DIG}\\
\texttt{LDBL\_MANT\_DIG}
\item[---] number of decimal digits, $n$, such that any floating-point number
  with $p$ radix $b$ digits can be rounded to a floating-point number with $n$
  decimal digits and back again without change to the value,\\
$\left\{ 
  \begin{array}{l l}
    plog_{10}~b & \quad \text{if $b$ is a power of 10}\\
    \lceil 1 + plog_{10}~b\rceil & \quad \text{otherwise}
  \end{array} \right. $\\\\
\begin{tabular}{lr}
\texttt{FLT\_DECIMAL\_DIG}&\hfil\hspace*{2cm}\texttt{6}\\
\texttt{DBL\_DECIMAL\_DIG}&\hfil\hspace*{2cm}\texttt{10}\\
\texttt{LDBL\_DECIMAL\_DIG}&\hfil\hspace*{2cm}\texttt{10}
\end{tabular}
\item[---] number of decimal digits, $n$, such that any floating-point number
in the widest supported floating type with $p_{max}$ radix $b$ digits can be
rounded to a floating-point number with $n$ decimal digits and back again
without change to the value,\\\\
$\left\{ 
  \begin{array}{l l}
    p_{max}log_{10}~b & \quad \text{if $b$ is a power of 10}\\
    \lceil 1 + p_{max}log_{10}~b\rceil & \quad \text{otherwise}
  \end{array} \right. $\\\\
\texttt{DECIMAL\_DIG}\hfil\hspace*{2cm}\texttt{10}
\item[---] number of decimal digits, $q$, such that any floating-point number
  with $q$ decimal digits can be rounded into a floating-point number with $p$
  radix $b$ digits and back again without change to the $q$ decimal digits,\\\\
$\left\{ 
  \begin{array}{l l}
    plog_{10}~b & \quad \text{if $b$ is a power of 10}\\
    \lfloor (p - 1)log_{10}~b\rfloor & \quad \text{otherwise}
  \end{array} \right. $\\\\
\begin{tabular}{lr}
\texttt{FLT\_DIG}&\hfil\hspace*{2cm}\texttt{6}\\
\texttt{DBL\_DIG}&\hfil\hspace*{2cm}\texttt{10}\\
\texttt{LDBL\_DIG}&\hfil\hspace*{2cm}\texttt{10}
\end{tabular}
\item[---] minimum negative integer such that \texttt{FLT\_RADIX} raised to one
  less than that power is a normalized floating-point number, $e_{min}$\\\\
\texttt{FLT\_MIN\_EXP}\\
\texttt{DBL\_MIN\_EXP}\\
\texttt{LDBL\_MIN\_EXP}
\item[---] minimum negative integer such that 10 raised to that power is in the range of
normalized floating-point numbers,$\lceil log10~b^{e_{min}-1}\rceil$\\\\
\begin{tabular}{lr}
\texttt{FLT\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{-37}\\
\texttt{DBL\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{-37}\\
\texttt{LDBL\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{-37}
\end{tabular}
\item[---] maximum integer such that \texttt{FLT\_RADIX} raised to one less
  than that power is a representable finite floating-point number,
  $e_{max}$\\\\
\texttt{FLT\_MAX\_EXP}\\
\texttt{DBL\_MAX\_EXP}\\
\texttt{LDBL\_MAX\_EXP}\\
\item[---] maximum integer such that 10 raised to that power is in the range of
  representable finite floating-point numbers, $\lfloor log_{10}((1 -
  b^{-p})b^{e_{max}} )\rfloor$\\\\
\begin{tabular}{lr}
\texttt{FLT\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{+37}\\
\texttt{DBL\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{+37}\\
\texttt{LDBL\_MIN\_10\_EXP}&\hfil\hspace*{2cm}\texttt{+37}
\end{tabular}
\end{itemize}

The values given in the following list shall be replaced by constant
expressions with implementation-defined values that are greater than or equal
to those shown:

\begin{itemize}
\item[---] maximum representable finite floating-point number, $(1 -
  b^{-p})b^{e_{max}}$\\\\
\begin{tabular}{lr}
\texttt{FLT\_MAX}&\hfil\hspace*{2cm}\texttt{1E+37}\\
\texttt{DBL\_MAX}&\hfil\hspace*{2cm}\texttt{1E+37}\\
\texttt{LDBL\_MAX}&\hfil\hspace*{2cm}\texttt{1E+37}
\end{tabular}
\end{itemize}

The values given in the following list shall be replaced by constant
expressions with implementation-defined (positive) values that are less than or
equal to those shown:

\begin{itemize}
\item[---] the difference between 1 and the least value greater than 1 that is
  representable in the given floating point type, $b^{1-p}$\\\\
\begin{tabular}{lr}
\texttt{FLT\_EPSILON}&\hfil\hspace*{2cm}\texttt{1E-5}\\
\texttt{DBL\_EPSILON}&\hfil\hspace*{2cm}\texttt{1E-9}\\
\texttt{LDBL\_EPSILON}&\hfil\hspace*{2cm}\texttt{1E-9}
\end{tabular}
\item[---] minimum normalized positive floating-point number,
  $b^{e_{min}-1}$\\\\
\begin{tabular}{lr}
\texttt{FLT\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}\\
\texttt{DBL\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}\\
\texttt{LDBL\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}
\end{tabular}
\item[---] minimum positive floating-point number\footnote{If the presence or
    absence of subnormal numbers is indeterminable, then the value is intended
    to be a positive number no greater than the minimum normalized positive
    number for the type.}\\\\
\begin{tabular}{lr}
\texttt{FLT\_TRUE\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}\\
\texttt{DBL\_TRUE\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}\\
\texttt{LDBL\_TRUE\_MIN}&\hfil\hspace*{2cm}\texttt{1E-37}
\end{tabular}
\end{itemize}

Conversion from (at least) \texttt{double} to decimal with
\texttt{DECIMAL\_DIG} digits and back should be the identity function.

\small{EXAMPLE 1 The following describes an artificial floating-point
  representation that meets the minimum requirements of this International
  Standard, and the appropriate values in a \texttt{<float.h>} header for type
  \texttt{float}:}

$$x = s16^e\sum_{k=1}^6f_k16^{-k}, ~~ -31\le~e~\le~+32$$

\small{\hspace*{2cm}\begin{tabular}{lr}
\texttt{FLT\_RADIX}&\hfil\hspace*{3cm}\texttt{16}\\
\texttt{FLT\_MANT\_DIG}&\hfil\hspace*{3cm}\texttt{6}\\
\texttt{FLT\_EPSILON}&\hfil\hspace*{3cm}\texttt{9.53674316E-07F}\\
\texttt{FLT\_DECIMAL\_DIG}&\hfil\hspace*{3cm}\texttt{9}\\
\texttt{FLT\_DIG}&\hfil\hspace*{3cm}\texttt{6}\\
\texttt{FLT\_MIN\_EXP}&\hfil\hspace*{3cm}\texttt{-31}\\
\texttt{FLT\_MIN}&\hfil\hspace*{3cm}\texttt{2.93873588E-39F}\\
\texttt{FLT\_MIN\_10\_EXP}&\hfil\hspace*{3cm}\texttt{-38}\\
\texttt{FLT\_MAX\_EXP}&\hfil\hspace*{3cm}\texttt{+32}\\
\texttt{FLT\_MAX}&\hfil\hspace*{3cm}\texttt{3.40282347E+38F}\\
\texttt{FLT\_MAX\_10\_EXP}&\hfil\hspace*{3cm}\texttt{+38}
\end{tabular}

EXAMPLE 2 The following describes floating-point representations that also meet
the requirements for single-precision and double-precision numbers in IEC
60559,\footnote{The floating-point model in that standard sums powers of b from
  zero, so the values of the exponent limits are one less than shown here.} and
the appropriate values in a \texttt{<float.h>} header for types \texttt{float}
and \texttt{double}:

$$x = s2^e\sum_{k=1}^{24}f_k2^{-k}, ~~ -125\le~e~\le~+128$$
$$x = s2^e\sum_{k=1}^{53}f_k2^{-k}, ~~ -1021\le~e~\le~+1024$$

\hspace*{2cm}\begin{tabular}{lr}
\texttt{FLT\_RADIX}&\hfil\hspace*{3cm}\texttt{2}\\
\texttt{DECIMAL\_DIG}&\hfil\hspace*{3cm}\texttt{17}\\
\texttt{FLT\_MANT\_DIG}&\hfil\hspace*{3cm}\texttt{24}\\
\texttt{FLT\_EPSILON}&\hfil\hspace*{3cm}\texttt{1.19209290E-07F}\\
\texttt{FLT\_DECIMAL\_DIG}&\hfil\hspace*{3cm}\texttt{9}\\
\texttt{FLT\_DIG}&\hfil\hspace*{3cm}\texttt{6}\\
\texttt{FLT\_MIN\_EXP}&\hfil\hspace*{3cm}\texttt{-125}\\
\texttt{FLT\_MIN}&\hfil\hspace*{3cm}\texttt{1.17549435E-38F}\\
\texttt{FLT\_TRUE\_MIN}&\hfil\hspace*{3cm}\texttt{1.40129846E-45F}\\
\texttt{FLT\_HAS\_SUBNORM}&\hfil\hspace*{3cm}\texttt{1}\\
\texttt{FLT\_MIN\_10\_EXP}&\hfil\hspace*{3cm}\texttt{-37}\\
\texttt{FLT\_MAX\_EXP}&\hfil\hspace*{3cm}\texttt{+128}\\
\texttt{FLT\_MAX}&\hfil\hspace*{3cm}\texttt{3.40282347E+38F}\\
\texttt{FLT\_MAX\_10\_EXP}&\hfil\hspace*{3cm}\texttt{+38}\\
\texttt{DBL\_MANT\_DIG}&\hfil\hspace*{3cm}\texttt{53}\\
\texttt{DBL\_EPSILON}&\hfil\hspace*{3cm}\texttt{2.2204460492503131E-16}\\
\texttt{DBL\_DECIMAL\_DIG}&\hfil\hspace*{3cm}\texttt{17}\\
\texttt{DBL\_DIG}&\hfil\hspace*{3cm}\texttt{15}\\
\texttt{DBL\_MIN\_EXP}&\hfil\hspace*{3cm}\texttt{-1021}\\
\texttt{DBL\_MIN}&\hfil\hspace*{3cm}\texttt{2.2250738585072014E-308}\\
\texttt{DBL\_TRUE\_MIN}&\hfil\hspace*{3cm}\texttt{4.9406564584124654E-324}\\
\texttt{DBL\_HAS\_SUBNORM}&\hfil\hspace*{3cm}\texttt{1}\\
\texttt{DBL\_MIN\_10\_EXP}&\hfil\hspace*{3cm}\texttt{-307}\\
\texttt{DBL\_MAX\_EXP}&\hfil\hspace*{3cm}\texttt{+1024}\\
\texttt{DBL\_MAX}&\hfil\hspace*{3cm}\texttt{1.7976931348623157E+308}\\
\texttt{DBL\_MAX\_10\_EXP}&\hfil\hspace*{3cm}\texttt{+308}
\end{tabular}

If a type wider than \texttt{double} were supported, then \texttt{DECIMAL\_DIG}
would be greater than 17. For example, if the widest type were to use the
minimal-width IEC 60559 double-extended format (64 bits of precision), then
\texttt{DECIMAL\_DIG} would be 21.
}
\normalsize
\section{Notes on Number System}
a number system is a system which determines the rules and symbols for numbers
on how we are going to use them.  A number system consists of symbols for
representing numbers and a dot for representing fractional numbers. Minus sign
is used to represent negative numbers. A number system ranges from $-\infty$
to $+infty$ . It is best represented by a straight line given below:

\begin{figure}[h!]
\begin{center}
\includegraphics{figs/ns.pdf}
\end{center}
\caption{Number Axis}
\end{figure}

Each point on this axis represents a number. It may be integer or fractional
number. An integer is a whole number like -1, -2, 0, 5, 7 etc. Floating-point
numbers have fractional parts like 1.234. The important fact to note is that
between any two points there exists infinite numbers. In other words between
any two numbers there exists infinite numbers. For example, between 1.2 and 1.3
there are 1.21, 1.22, 1.23..., 1.29. Moreover between 1.21 and 1.22 there are
1.211, 1.212, 1.213 and so on. It enables us to represent a point on this
axis. The numbers I have written are supposedly in decimal number system. Base
of decimal number system is 10. Why because it consists of 10 distinct symbols
0 through 9. Similarly we can have any other number system. Popular number
systems in computers are binary, octal and hexadecimal not to mention decimal
ofcourse.

A number in a generic number system is given below:
$$(.. c_mb^{m-1} + c_{m-1}b^{m-2}+ ... + c_2b^1 + c1_b^0 + c_{-1}b^{-1} +
... + c_{-m}b^{-m} ) \\ = (... c_mc_{m-1}...c_2c_1.c_{-1}...c_{-m})_b$$

All the terms with $c$  are called digits. The leftmost or leading digit is
called \textit{most significant digit} and the rightmost or trailing digit is
called \textit{least significant digit}. The . is called a point which
separates the integral part which is toards its left from the fractional part
which is towards its right. $b$  is known as radix or base of the number
system. Note that all digits will be between $0$ to $b-1$. So in our decimal
system $b$  is 10 therefore we have digits from 0 to 9. In binary number system
it is 2 therefore digits permitted are 0 and 1.

\subsection{Binary Number System}
As the name suggests binary number system has base of 2. Therefore it has only
two symbols. 0 and 1. This is the most popular system for computers becasue TTL
NAND and NOR gates which are the most basic logic gates using which other gates
are implemented in processor has only two voltage output levels because of
their operation in cut-off and saturation zones. These terms are better
understood with the help of a book on electronics which is out of scope of this
book. All binary numbers consist of 0 and 1. So the count is like 0, 1, 10, 11,
100, 101, 110, 111, 1000 and so on.

\subsubsection{Conversion of Decimals and Bianries}
Consider a decimal number. Let us say 53 then how would be convert it to
binary. The technique is that of division. Please examine following carefully:

\hspace*{2cm}
\begin{Verbatim}[frame=single]
2 | 53 | 1
----------
2 | 26 | 0
----------
2 | 13 | 1
----------
2 | 6  | 0
----------
2 | 3  | 1
----------
2 | 1  |
\end{Verbatim}

So the binary is $110101_2$. First we divide 53 by 2 and write the
remainder. Then quotient is 26. We repeat the process for 26 therefore
remainder is 0 and quotient is 13. This we go on repeatin till we have 1 as
quotient. Note that all the remainders will be 0 or 1 because divisor is
2. Similarly, final quotient is always 1. Now we take final quotient and start
writing remainders from top to bottom.

To convert binary to decimal let us examine following:

$1*2^5 +1*2^4 +0*2^3 +1*2^2 +0*2^1 +1*2^0 =53_{10}$

The power is to 2 because 2 is the base of source. It starts from 0 for unit's
position and increases to 1 and 2 for ten's and hundred's position and so
on. 1's and 0's are the values of that place. If you note carefully powers of 2
grow like 1, 2, 4, 8, 16, 32, 64, 128 and so on. Any number can be written by
using these powers at most one time. For example consider 100. I know it is
less than 128 so I will use 64. Then 36 remains. So I will use 32 and then
4. This means 100=64+32+4  which means power 6, 5 and 2 have been
used. Therefore, I can quickly write down number as $1100100_2$.

Fractional numbers are slightly more complicated. Let us consider $1.1_2$  . In
decimal it will be $1+\frac{1}{2}$. This is 1.5 in decimal. Note that when you
convert a fractional part of binary to decimal denominator will always be power
of 2. For that matter when you convert from any base to decimal denominator
will be powers of that base. Important Therefore, when you convert from decimal
to some base n then denominator of that decimal number can have only those
prime factors which are available in the set of prime factors of n. 

Let us say we have a fractional number in decimal .59 then to convert it to
decimal we multiply it with 2 which yields 1.018 which is greater than 1 so our
equivalent binary number is .1. Now we subtract 1 from 1.18 to get .18 which
is less than 1 so we multiply it with 2 again to get .36. Now since this is
less than 1 our equivalent binary number is .10. Repeating the process we get
.72 and .100 then 1.44 and .1001. We put 1 in binary part because decimal part
has become greater than 1. Now again we subtract 1 from decimal part to get .44
and repeat the process.

Operations such as addition, subtraction, multiplication and division are
similar in all number systems.

Now let us see a program to see how we can take input and print the floating
point numbers.

\begin{Verbatim}[frame=single]
#include <stdio.h>

int main()
{
  float f = 0.0;
  double d = 0.0;
  long double ld = 0.0;

  printf("Enter a float, double and long double separated by space:\n");
  scanf("%f %lf %Lf", &f, &d, &ld);

  printf("You entered %f %lf %Lf\n", f, d, ld);

  return 0;
}
\end{Verbatim}

If you run this you might have following output:

\begin{Verbatim}[frame=single]
$ ./a.out
Enter a float, double and long double separated by space:
3.4 5.6 7.8
You entered 3.400000 5.600000 7.800000
\end{Verbatim}

By default these print upto six significant digits but doubles have double
precision as we have studied. Now that we know basic types let us learn a bit
about input/output.

\section{Boolean Data Type}
A boolean type has only two values possible; \texttt{true} and
\texttt{false}. Fundamentally a boolean is an integer. 0 is considered as
\texttt{false} while all other are treated as \texttt{true} including negative
integers. \texttt{true} and \texttt{false} are macros (which we will see later)
which are defined in \texttt{<stdbool.h>} and they expand to 1 and 0
respectively. The type \texttt{bool} is a macro which expands to
\texttt{\_Bool}. Let us see a small program with bolleans:

\begin{Verbatim}[frame=single]
#include <stdio.h>
#include <stdbool.h>

int main()
{
  bool bcpp      = 4;
  _Bool bc       = 5;
  bool True      = true;
  _Bool False    = false;
  bool bFalseCPP = -4;
  _Bool bFalseC  = -7;

  printf("%d %d %d %d %d %d\n", bcpp, bc, True, False, bFalseCPP, bFalseC);

  return 0;
}
\end{Verbatim}

and the output is:

\begin{Verbatim}[frame=single]
1 1 1 0 1 1
\end{Verbatim}

Note that \texttt{true} and \texttt{false} are keywords while \texttt{True} and
\texttt{False} are identifiers.

\section{Complex Type}
C99 introduced another type \texttt{complex}. As you may know a complex has two
parts real and imaginary. These parts of a complex individually are
floating-point numbers i.e. they can be represented by \texttt{float, double}
or \texttt{long double}. The header \texttt{<complex.h>} deals with complex
numbers and there are lots of useful functions to use and manipulate complex
numbers which are detailed in the reference. Let us see a simple example:

\begin{Verbatim}[frame=single]
#include <stdio.h>
#include <complex.h>

int main()
{
  double complex z = 4.0 + 3.0i;

  printf("Absolute value of z is %lf\n", cabs(z));

  double complex zConj = conj(z);
  printf("Imaghinary part of conjugate is now %lf\n", cimag(zConj));

  return 0;
}
\end{Verbatim}

Since we have used \texttt{<complex.h>} we need to link math library to compile
this program so the compilation command would look like \texttt{\$gcc -o complex
complex.c -lm}. The \texttt{-lm} part is mandatory for compilation of this
program. Let us see the output:

\begin{Verbatim}[frame=single]
Absolute value of z is 5.000000
Imaghinary part of conjugate is now -3.000000
\end{Verbatim}

I have shown only two functions \texttt{cabs} and \texttt{cimag} but there are
a lot more and very useful functions available to do computations on complex
numbers. The way to declare a complex number is shown. It is a combination of
real part and imaginary part where imaginary part is coupled with $i$ which is
given by $i = \sqrt{-1}$. Here, \texttt{cabs} computes absolute value of
complex number which is given by $\sqrt{x^2 + y^2}$ where complex number is
given by $x + iy$. We will see rest of the functions in reference.

\section{Void and Enum}
The \texttt{void} type comprises an empty set of values; it is an incomplete
object type\footnote{An incomplete type is a type whose size is unknown.} that
cannot be completed. You cannot declare variables with type void. You cannot
declare an array of\texttt{void} type. Any declaration which requires size of
type to be known cannot have \texttt{void} as its type. However, we can declare
pointers of type \texttt{void} because pointers do not require size of type to
be known. For this reason \texttt{void} pointers are used as generic pointers
and is used to convert one type of pointers into another. It is a low-level
type and should be used sparigly. We will see examples of \texttt{void} type
later in the book.

Enum type is an integral type and is used as symbolic constants. An enumeration
is is a set of integers(values). You can do all operations of an enum on an
enumeration member which you can do on an integer. It starts from zero by
default and increments by one unless specifically specified. Given below is an
example of \texttt{enum} type.

\begin{Verbatim}[frame=single]
#include <stdio.h>

int main()
{
  typedef enum {zero, one, two} enum1;
  typedef enum {alpha=-5, beta, gamma, theta=4, delta, omega} enum2;

  printf("zero = %d, one = %d, two=%d\n", zero, one, two);
  printf("alpha = %d, beta = %d, gamma=%d, theta=%d, delta=%d, omega=%d\n", \
          alpha, beta, gamma, theta, delta, omega);

  return 0;
}
\end{Verbatim}

and the output is

\begin{Verbatim}[frame=single]
zero = 0, one = 1, two=2
alpha = -5, beta = -4, gamma=-3, tehta=4, delta=5, omega=6
\end{Verbatim}

\section{Constants}
There are four categories of constants: character, integer, floating-point, and
enumeration constant. There are certain rules about constants. Commas and
spaces are not allowed except for character and string constants. Their range
cannot outgrow the range of there data type. For numeric type of stants they
can have a leading (-)minus sign.

Given below is an example of integer constants:

\begin{Verbatim}[frame=single]
#include <stdio.h>

int main()
{
  int decimal = 7;
  int octal = 06;
  int hex = 0xb;

  printf("%d %o %x\n", decimal, octal, hex);

  return 0;
}
\end{Verbatim}

and the output is:

\begin{Verbatim}[frame=single]
7 6 b
\end{Verbatim}

As you can see there are three different categories for integer constants:
decimal constants (base 10), octal constants (base 8) and hexadecimal constants
(base 16). Also, you must have noticed how a zero is prefixed before octal type
and a zero and x for hexadecimal type. The \texttt{\%d} format specifier is
already known to you for signed decimals. However, now you know two more
\texttt{\%o} and \texttt{\%x} for unsigned octal and unsigned hexadecimal
respectively. For unsigned integer it is \texttt{\%u}. There is one more format
specifier which you may encounter for signed decimal and that is
\texttt{\%i}. Note that there is nothing for binary constants.

A floating-point constant is a base-10 number that contains either decimal
point or exponent or both. Given below is an example of floating-point
constants:

\begin{Verbatim}[frame=single]
#include <stdio.h>

int main()
{
  float f = 7.5384589234;
  double d = 13.89457883453857823;
  long double ld = 759.8263478234729;

  printf("%f %lf %Lf\n", f, d, ld);

  return 0;
}
\end{Verbatim}

and the output is

\begin{Verbatim}[frame=single]
7.538459 13.894579 759.826348
\end{Verbatim}

For example 123456 can be wriiten as one of 1.23456e5, 1.23456e+5, 1.23456E5,
.123456e6, 12.3456E+4 etc. The expoenent is integer and it cannot be
floating-point number.

A character constant is a single character enclosed in apostrophes. Some
examples of a character constants are \texttt{'A', 'T', ')', '?'. ' '}. Commas
and blanks are allowed as character constants in apostrophes. The character
constants are fundamentally integers and all arithmetic operations can be
performed over them. These values depend on the character set of the computer
in use. However, in this book we are concerned about ASCII character set.

\section{Escape Sequences}
There are certain characters which are not on keyboard and are not displayed in
the form on printing characters. Some of these are expressed using
\textit{escape sequences}. An escape sequence always begins with a backslash
and is followed by on or more characters. Given below is the table of escape
sequences:

\begin{table}[!h]
\begin{center}
\caption{Escape Sequences}
\begin{longtable}{lcc}
\textbf{Character}&\textbf{Escape Seqquence}&\textbf{ASCII Value}\\
bell (alert)&$\backslash$a&007\\
backspace&$\backslash$b&008\\
horizontal t&$\backslash$t&009\\
vertical tab&$\backslash$v&011\\
newline (line feed)&$\backslash$n&010\\
form feed&$\backslash$f&012\\
carriage return&$\backslash$r&013\\
quotation mark(")&$\backslash$"&034\\
apostrophe(')&$\backslash$'&039\\
question mark(?)&$\backslash$?&063\\
backslask ($\backslash$)&$\backslash\backslash$&092\\
null&$\backslash$0&000
\end{longtable}
\end{center}
\end{table}
